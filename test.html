
  function playDiagonalEffect() {
    // 1. Créer les divs dès l’appel
    const createdDivs = [];
    for (let i = 0; i < 3; i++) {
      const div = document.createElement("div");
      div.textContent = "Div animée " + (i + 1);
      div.style.padding = "1em";
      div.style.margin = "1em";
      div.style.background = "#eee";
      div.style.borderRadius = "8px";
      div.style.boxShadow = "0 2px 10px rgba(0,0,0,0.1)";
      div.style.position = "relative";
      div.style.zIndex = 1; // en dessous du canvas
      document.body.appendChild(div);
      createdDivs.push(div);
    }
  
    // 2. Créer le canvas d'animation
    const canvas = document.createElement("canvas");
    canvas.style.position = "fixed";
    canvas.style.top = 0;
    canvas.style.left = 0;
    canvas.style.width = "100vw";
    canvas.style.height = "100vh";
    canvas.style.pointerEvents = "none";
    canvas.style.zIndex = 9999;
    document.body.appendChild(canvas);
  
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  
    const width = canvas.width;
    const height = canvas.height;
  
    const totalDuration = 4000;
    const phaseDuration = totalDuration / 4;
  
    const phases = [
      { from: { x: 0, y: 0 }, to: { x: width, y: height }, ease: easeSlow },
      { from: { x: 0, y: height }, to: { x: width, y: 0 }, ease: easeSlow },
      { from: { x: 0, y: 0 }, to: { x: width, y: height }, ease: easeFast },
      { from: { x: 0, y: height }, to: { x: width, y: 0 }, ease: easeFast }
    ];
  
    let startTime = null;
  
    function easeSlow(t) {
      return t * t * t;
    }
  
    function easeFast(t) {
      return Math.pow(t, 8);
    }
  
    function draw(timestamp) {
      if (!startTime) startTime = timestamp;
      const elapsed = timestamp - startTime;
  
      ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
      ctx.fillRect(0, 0, width, height);
  
      if (elapsed < totalDuration) {
        const phaseIndex = Math.floor(elapsed / phaseDuration);
        const phaseTime = elapsed % phaseDuration;
        const t = Math.min(phaseTime / phaseDuration, 1);
  
        const phase = phases[phaseIndex];
        const progress = phase.ease(t);
  
        const x = phase.from.x + (phase.to.x - phase.from.x) * progress;
        const y = phase.from.y + (phase.to.y - phase.from.y) * progress;
  
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, Math.PI * 2);
        ctx.fillStyle = "white";
        ctx.shadowColor = "white";
        ctx.shadowBlur = 25;
        ctx.fill();
  
        requestAnimationFrame(draw);
      } else {
        // 3. À la fin → supprimer canvas + divs
        canvas.remove();
        createdDivs.forEach(div => div.remove());
      }
    }
  
    requestAnimationFrame(draw);
  }
 
  